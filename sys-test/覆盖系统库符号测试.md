# 符号覆盖测试

本文整理了多种在不修改被测源码的前提下，通过符号覆盖、预加载或直接在测试驱动中包含目标 C/C++ 源码来实现特定测试逻辑的方法。目标读者是希望快速替换或拦截运行时行为以实现单元/集成测试、故障注入或行为观测的工程师。文章偏重实践：原理、常见方法、示例和注意事项。

## 原理简介

- **动态链接符号预占（symbol interposition）**：当 ELF 可执行文件在运行时通过动态链接器解析符号时，动态库中导出的符号可以“遮蔽”（preempt）可执行文件所期望的同名动态符号。常见手段有 `LD_PRELOAD`、动态库先后加载顺序等。
- **链接时包装（linker wrap）**：在链接阶段使用 `-Wl,--wrap=symbol` 把对 `symbol` 的引用重定位到 `__wrap_symbol`，原始实现可以通过 `__real_symbol` 调用。适用于可以重新链接目标的场景。
- **包含源文件（#include "target.c"）**：在测试驱动中直接包含被测的 C 源文件，借助宏和条件编译改变行为或替换符号。此法不改原文件，但需要重新编译被测源文件作为测试的一部分。
- **符号重命名/二进制修补**：使用 `objcopy`、`ld`、链接脚本等工具修改符号表、重命名符号或用替换对象文件替换符号地址。复杂但不依赖运行时预加载。

## 方法清单与示例

1 使用 LD_PRELOAD（最常用、无需改被测二进制）

说明：编写一个共享库，导出与目标库或可执行文件相同符号（函数名或全局变量名），并在运行目标时通过 `LD_PRELOAD` 指定该共享库，让动态链接器优先解析这些符号。

示例：拦截 `open` 并打印日志

```c
// override_open.c
#define _GNU_SOURCE
#include <stdio.h>
#include <dlfcn.h>
#include <fcntl.h>

static int (*real_open)(const char *pathname, int flags, ...) = NULL;

// 一种函数拦截/Hook 模式
// 最终就是每次调用 open, 都会调用这里，内部这里实现会转到调用系统open
// 这样就在每次open时加了特定的逻辑了，可以是日志或者统计等等
int open(const char *pathname, int flags, ...) {
    if (!real_open) {
        // 在当前库的下一个库中查找真实的 open 实现
        real_open = dlsym(RTLD_NEXT, "open");
    }
    printf("[preload] open intercepted: %s\n", pathname);
    return real_open(pathname, flags);
}
```

编译并运行：

```bash
gcc -fPIC -shared -o liboverride.so override_open.c -ldl
LD_PRELOAD=./liboverride.so ./your_target_binary
```

注意：

- 适用于动态链接的目标；静态链接或某些符号被导出为不可被劫持（例如绑定时使用了 `-Bsymbolic`）时无效。
- 小心重入：别在被覆盖函数里调用会再次触发同名覆盖的函数，必要时使用 `dlsym(RTLD_NEXT, ...)` 或保存真实函数指针。

2 链接时的 --wrap（需要可重新链接对象）

说明：如果你能重新链接目标（或有目标的 object 文件），使用链接器的 `--wrap` 可以把所有对 `symbol` 的引用重定向到 `__wrap_symbol`。原始实现可通过 `__real_symbol` 调用。

示例：

创建 wrapper：

```c
// wrap_malloc.c
#include <stdlib.h>
#include <stdio.h>

void * __real_malloc(size_t size);

void * __wrap_malloc(size_t size) {
    printf("[wrap] malloc %zu\n", size);
    return __real_malloc(size);
}
```

链接目标时添加：

```bash
gcc myprog.o wrap_malloc.o -Wl,--wrap=malloc -o myprog
```

优点：可以在不使用 LD_PRELOAD 的前提下实现替换，适合构建阶段注入。

3 在测试驱动中直接包含目标源码

说明：写一个测试驱动 `test_main.c`，在合适的位置 `#define` 替换宏或 stub，然后 `#include "../path/to/target.c"`。这会把被测源编译进测试二进制，测试驱动可控制全局变量或函数实现顺序。

示例：

```c
// test_driver.c
#include <stdio.h>
#define TEST_MODE
#include "../src/target.c"  // 直接包含源码（仅在你愿意这样做时）

int main(void) {
    // 调用 target.c 中的接口或测试点
    target_entry();
    return 0;
}
```

备注：

- 方便且不需要修改源文件，但必须能够以这种方式重新编译目标代码（可能需要处理静态变量/重定义等）。
- 可以在被包含的源码中用 `#ifdef TEST_MODE` 做条件编译以改变逻辑。

4 使用动态符号工具与检查（定位问题与验证覆盖是否生效）

- 列出运行时需要的共享库：`ldd ./your_target_binary`
- 查看动态符号表：`readelf -Ws ./your_target_binary` 或 `nm -D ./libxyz.so`
- 运行时调试：`LD_DEBUG=bindings LD_DEBUG_OUTPUT=./ld.debug LD_PRELOAD=./liboverride.so ./your_target_binary`（部分系统支持）

5 C++ 的特殊注意点

- C++ 符号被 name-mangle，直接用 `open` 那样的函数名替换常见于 C；C++ 需要找到被导出的 mangled 名称（`nm -D` + `c++filt`）并以同样的符号导出，或在包装库中提供 `extern "C"` 的 C 接口供 C 层使用。
- 覆盖虚函数更困难：可以通过替换创建对象的工厂函数或在运行时修改 vtable（不推荐）来实现。更可靠的方式是通过测试驱动包含源码并调整为可测试的设计。

6 静态链接与不可预期情况

- 如果目标被静态链接（`-static`）或将函数静态化（`static` 关键字），运行时的 `LD_PRELOAD` 无效。
- 对于静态二进制，可以考虑重编译目标（包含测试代码）、或使用二进制工具（`objcopy` 重命名符号、`patchelf` 修改依赖）进行更复杂的二进制层面替换，但风险和复杂度更高。

7 其他技术：LD_AUDIT、seccomp、ptrace

- `LD_AUDIT` 可实现低层次符号绑定审计与拦截；更复杂但功能强大。
- `ptrace`、`strace` 适合观察与注入少量行为，但通常用于进程级测试或调试，不适合大规模单测替换。

实用检查与调试技巧

- 确认目标是否是动态链接：`file ./your_target_binary`（查找 "dynamically linked"）
- 用 `ldd` 查看加载的库。
- 用 `nm -D liboverride.so` 确认你的替换库导出了目标符号。
- 在替换函数里打印日志以确认是否生效；必要时把输出重定向到文件以免干扰标准输出。

示例命令汇总

```bash
# 构建 LD_PRELOAD 替换库
gcc -fPIC -shared -o liboverride.so override_open.c -ldl

# 运行并预加载
LD_PRELOAD=./liboverride.so ./your_target_binary

# 查看符号
nm -D liboverride.so | c++filt
readelf -Ws ./your_target_binary | grep open
ldd ./your_target_binary
```

最佳实践与注意事项（要点）

- 首选 `LD_PRELOAD`：对现成的动态二进制最方便、侵入性最小。
- 避免在被覆盖函数内做会触发同名调用的操作（用 `dlsym(RTLD_NEXT, ...)` 获取下一个实现）。
- 在替换实现中保持线程安全，注意初始化顺序（`__attribute__((constructor))` 可用于初始化，但要小心竞态）。
- 控制替换范围：根据环境变量或进程名在运行时决定是否启用替换逻辑，避免影响其他测试或系统程序。
- 在 C++ 中，尽量通过工厂函数或接口注入来替换实现，而不是直接尝试替换内部虚表。

结语

本文提供了一套不修改被测源码、也不完全依赖外部库的测试方法：从运行时 `LD_PRELOAD`、链接时 `--wrap`、到把源码包含进测试驱动。选择哪种方式取决于你能否重新链接、目标是否动态链接、以及你对风险和复杂度的容忍度。通常推荐先尝试 `LD_PRELOAD` 和包含源码的测试驱动，两者能覆盖大多数日常测试与故障注入场景。
