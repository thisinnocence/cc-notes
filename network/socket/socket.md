# socket demo

例子是chatgpt生成的，对于这种标准API的使用举例，非常准确方便。

## TCP stream

SOCK_STREAM: Indicates a TCP socket (stream-based communication).

下面表格也是ChatGPT生成，挺方便：

| 函数       | 用途                     | 特定于套接字 | 特点                                              | 适用场景                         |
|------------|--------------------------|--------------|---------------------------------------------------|----------------------------------|
| `read`     | 从文件描述符读取数据     | 否           | 简单读取，不适用于接收控制信息或标志               | 通用数据读取，包括套接字和文件   |
| `recv`     | 从套接字接收数据         | 是           | 支持标志参数，提供更精细的控制                     | 套接字数据接收，支持 `flags` 控制|
| `recvmsg`  | 从套接字接收消息         | 是           | 支持接收多个缓冲区的数据和控制信息，功能强大        | 复杂数据和控制信息的接收，使用 `struct msghdr *msg` 描述消息 |
| `recvfrom` | 从套接字接收数据         | 是           | 支持从指定的地址接收数据                           | 通常用于UDP，支持获取发送方地址 |
| `write`    | 向文件描述符写入数据     | 否           | 简单写入，不适用于发送控制信息或标志               | 通用数据写入，包括套接字和文件   |
| `send`     | 向套接字发送数据         | 是           | 支持标志参数，提供更精细的控制                     | 套接字数据发送，支持 `flags` 控制|
| `sendmsg`  | 向套接字发送消息         | 是           | 支持发送多个缓冲区的数据和控制信息，功能强大        | 复杂数据和控制信息的发送，使用 `struct msghdr *msg` 描述消息 |
| `sendto`   | 向指定地址发送数据       | 是           | 支持将数据发送到指定地址                           | 通常用于UDP，指定发送目标地址   |

API按照顺序支持的场景依次变的复杂，可以看官方API说明。

是阻塞还是非阻塞，通过 `fcntl` 来设置对应 socket fd即可。
同步阻塞接口代码会相对好些，阻塞后，OS会调度对应thread让出来CPU，直到有数据重新调度唤醒执行。
