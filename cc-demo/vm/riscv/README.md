# RISC-V 裸机程序示例

-----

这个目录包含一个简单的 RISC-V 裸机（bare-metal）程序示例，用于演示基本的 C 语言编译、链接过程，以及如何为 RISC-V 架构创建一个可以在仿真器上运行的 ELF 二进制文件。

## 文件概览

* **`main.c`**: 程序的 C 语言源代码。它包含一个 `_start` 函数作为程序的入口点，以及一个简单的 `add` 函数。
* **`link.ld`**: GNU Linker (ld) 脚本。这个文件是编译过程中的关键部分，它定义了程序在内存中的布局、各个代码/数据段的放置位置，以及如何生成最终的 ELF 文件。
* **`Makefile`**: 用于自动化编译和链接过程的 Makefile。

## 编译工具链

本示例需要 `riscv64-linux-gnu-gcc` 交叉编译工具链。

```bash
sudo apt update
sudo apt install gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu
```

## 编译和运行

1. **编译程序**:
    在项目根目录下，直接运行 `make` 命令：

    你可能会看到一个警告信息：`rv64.bin has a LOAD segment with RWX permissions`。对于裸机程序而言，这是正常且预期的行为，表示程序段拥有读、写、执行权限，这在没有操作系统进行细致内存权限管理的裸机环境中是常见的。

2. **运行程序**:
    你可以使用 RISC-V 仿真器（如 QEMU 或 Spike）来运行生成的 `rv64.bin` 文件。

    使用 QEMU（通常你需要安装 `qemu-system-riscv64`）：

    ```bash
    qemu-system-riscv64 -nographic -machine virt -cpu rv64gc -kernel rv64.bin
    ```

    或者使用 Spike (RISC-V ISA Simulator)：

    ```bash
    spike rv64.bin
    ```

    由于这是一个非常简单的裸机程序，`_start` 函数只是调用了 `add` 函数，然后进入一个无限循环 (`while(1)`)。因此，在仿真器中运行后，你可能看不到任何输出，程序会持续运行直到你手动终止仿真器。

-----

## ELF 文件格式简介

### ELF文件格式概述

**ELF (Executable and Linkable Format)** 是一种标准的文件格式，用于可执行文件、目标文件、共享库和核心转储文件。它是 Unix-like 系统（包括 Linux）上最常用的二进制文件格式。理解 ELF 格式也有助于你了解二进制文件的结构以及加载器（仿真器）如何处理你的程序。

一个 ELF 文件主要包含以下几个关键部分：

1. **ELF Header (ELF 头)**:
      * 位于文件开头，包含整个文件的**元数据**，例如文件类型（可执行文件、目标文件等）、目标架构（RISC-V 64位）、入口点地址（即 `_start` 函数的地址）、以及其他头（如程序头和节头）的位置和大小。
2. **Program Header Table (程序头表)**:
      * 这是一个结构体数组，每一个结构体被称为一个**程序头 (Program Header)**。
      * 程序头描述了**如何将文件中的各个部分映射到内存中**以供执行。对于可执行文件，它主要包含 `PT_LOAD` 类型的段，这些段指定了文件中的哪一部分（文件偏移量、大小）应该被加载到内存的哪个地址（虚拟内存地址 VMA）以及其内存权限（读、写、执行）。
      * 在裸机开发中，加载器（如 QEMU）会解析这个表，然后将指定的字节范围从 ELF 文件加载到模拟内存的对应位置。
3. **Section Header Table (节头表)**:
      * 这是一个结构体数组，每一个结构体被称为一个**节头 (Section Header)**。
      * 节头描述了文件中的**各个逻辑节 (Section)**，例如 `.text`（代码）、`.data`（已初始化数据）、`.rodata`（只读数据）、`.bss`（未初始化数据）等等。这些节在链接时非常重要，但在程序执行时，通常由程序头来指导加载。
      * 对于可执行文件，节头表是可选的，一些优化后的二进制文件可能会移除它以减小文件大小。

在我们的 `link.ld` 脚本中，我们正是通过 `PHDRS` 和 `SECTIONS` 块来精确控制这些 ELF 结构，确保 `rv64.bin` 能够被 RISC-V 仿真器正确地加载和执行。

### ELF 文件结构简化图

为了更好地理解 ELF 文件中这些组件的关系，我们可以将其简化表示如下：

```txt
+---------------------+ 0x0 (文件起始)
|     ELF Header      |
+---------------------+
|                     |
|  Program Headers    |  <-- Program Header Table (描述了如何加载以下段)
|                     |
+---------------------+
|                     |
|  Padding (可选)     |  <-- 填充，确保后续段对齐
|                     |
+---------------------+
|    .text_segment    |
|   (Code, R/O Data,  |  <-- PT_LOAD 段的内容（来自 .text, .rodata, .data）
|   Initialized Data) |
+---------------------+
|                     |
|     (其他可选LOAD段) |
|                     |
+---------------------+
|                     |
|  Section Headers    |  <-- Section Header Table (如果存在的话，描述各个逻辑节)
|  (可选，运行时通常不加载) |
|                     |
+---------------------+
```

* **ELF Header 和 Program Headers** 通常位于文件的最前端，它们告诉加载器在哪里找到后续可加载的数据。
* `.text_segment` 是我们通过链接脚本定义的主要可加载部分，它包含了程序的实际代码和数据。
* `Padding` 区域可能存在，用于确保各个段在文件中的偏移量满足对齐要求。
* `Section Headers` 虽然在图中显示在末尾，但其在文件中的实际位置由 ELF 头中的偏移量字段指定，它可以位于文件的任何地方，甚至在可加载段之前。对于bare-metal loader而言，通常只关心程序头表，因为它直接指导内存映射。

-----

## 链接脚本 (`link.ld`) 说明

`link.ld` 是这个裸机程序的核心配置之一，它告诉链接器如何将编译后的代码和数据组织成最终的 `rv64.bin` 文件。以下是其中关键部分的解释：

-----

### 1\. `ENTRY(_start)`

```ld
ENTRY(_start)
```

* **含义**: 指定程序的**入口点**为 `_start` 函数。当仿真器（或真实硬件）加载并开始执行程序时，它会从 `_start` 函数的地址开始运行。`_start` 通常是 C 代码的第一个函数，负责初始化（如设置栈指针，清除 BSS 段等）然后跳转到 `main` 函数（如果存在）。

-----

### 2\. `MEMORY` 块

```ld
MEMORY
{
  RAM (rwx) : ORIGIN = 0x0, LENGTH = 256M
}
```

* **含义**: 定义了目标系统的**内存布局**。
  * `RAM`: 自定义的一个内存区域名称。
  * `(rwx)`: 指定该内存区域的访问权限为读 (r)、写 (w) 和执行 (x)。
  * `ORIGIN = 0x0`: 指定 `RAM` 内存区域的**起始地址**为 `0x0`。对于裸机程序，通常从地址 0 开始是合理的，但也需要根据你的仿真器或硬件的具体内存映射来调整。
  * `LENGTH = 256M`: 指定 `RAM` 内存区域的**总长度**为 256MB。

-----

### 3\. `SECTIONS` 块

```ld
SECTIONS
{
  . = ORIGIN(RAM);

  .text_segment :
  {
    . = ALIGN(0x1000); /* Ensure code starts at a 4KB aligned address */
    PROVIDE(start_of_program = .);

    KEEP(*(.text.startup))
    *(.text)
    *(.text.*)

    . = ALIGN(4);
    *(.rodata)
    *(.rodata.*)

    . = ALIGN(4);
    *(.data)
    *(.data.*)

    . = ALIGN(0x1000);
  } > RAM : text_rodata_data

  .bss (NOLOAD) : ALIGN(8)
  {
    *(.bss)
    *(.bss.*)
    *(COMMON)
    . = ALIGN(8);
  } > RAM

  . = ALIGN(0x1000);
  _end = .;
}
```

* **含义**: 定义了程序中各种代码和数据段如何被组织到输出文件中，以及它们在内存中的地址。
  * `. = ORIGIN(RAM);`: 将当前地址计数器 (`.`) 设置为 `RAM` 内存区域的起始地址（即 `0x0`），这意味着所有的段都将从这个地址开始计算其虚拟内存地址 (VMA)。
  * **`.text_segment`**: 这是最重要的一个段，它包含了程序的代码 (`.text`)、只读数据 (`.rodata`) 和已初始化数据 (`.data`)。
    * `. = ALIGN(0x1000);`: **关键行。** 这条指令将当前地址计数器 `.` 对齐到下一个 4KB (0x1000) 边界。由于这个段最终会成为 `text_rodata_data` 这个 `PT_LOAD` 程序头的一部分，而该 `PT_LOAD` 头是从文件偏移 `0` 处加载的，因此 `ALIGN(0x1000)` **巧妙地为 ELF 文件头和程序头表预留了前 4KB 的空间**。你的实际代码将从内存地址 `ORIGIN(RAM) + 0x1000` 处开始。
    * `PROVIDE(start_of_program = .);`: 创建一个名为 `start_of_program` 的全局符号，其值为当前地址。这对于调试或外部程序获取实际代码开始地址很有用。
    * `KEEP(*(.text.startup))`: 确保 `.text.startup` 段（通常包含 `_start` 函数）即使没有被其他代码直接引用，也会被保留并放置到这里。
    * `*(.text)` / `*(.text.*)`: 包含所有编译后的可执行代码。
    * `*(.rodata)` / `*(.rodata.*)`: 包含所有只读数据（例如字符串常量）。
    * `*(.data)` / `*(.data.*)`: 包含所有已初始化的全局变量和静态变量。
    * `> RAM`: 将 `.text_segment` 放置在 `RAM` 内存区域内。
    * `: text_rodata_data`: **关键部分。** 将 `.text_segment` 与 `PHDRS` 块中定义的 `text_rodata_data` 程序头关联起来。这意味着这个段的内容将作为 `text_rodata_data` 程序头描述的可加载区域的一部分。
  * **`.bss` (NOLOAD)**: 包含未初始化的全局变量和静态变量。
    * `NOLOAD`: 告诉链接器这个段不需要从 ELF 文件中加载到内存。在裸机程序中，这通常意味着你的 `_start` 代码需要手动将这部分内存清零。
    * `ALIGN(8)`: 将 `.bss` 段对齐到 8 字节边界。
    * `> RAM`: 将 `.bss` 段放置在 `RAM` 内存区域内。
  * `_end = .;`: 定义一个 `_end` 符号，指向所有已分配段的末尾，可以用来获取程序的总内存占用。

-----

### 4\. `PHDRS` 块

```ld
PHDRS
{
  text_rodata_data PT_LOAD FILEHDR PHDRS FLAGS(7) AT (0);
}
```

* **含义**: 定义了程序头 (Program Headers)，它们是 ELF 文件结构的一部分，告诉加载器（如仿真器）如何将文件的不同部分映射到内存中。
  * **`text_rodata_data` PHDR**:
    * `PT_LOAD`: 这是一个可加载的段，意味着它需要被加载到内存中。
    * `FILEHDR`: 这个指令告诉链接器，ELF 文件头本身是这个可加载段的一部分。
    * `PHDRS`: 这个指令告诉链接器，程序头表本身也是这个可加载段的一部分。
    * `FLAGS(7)`: 设置此段的权限为读 (R=4)、写 (W=2) 和执行 (X=1)，总和为 7。对于简单的裸机系统，通常会将整个加载段设置为 RWX。
    * `AT (0)`: 指定此加载段在文件中的偏移量为 `0`。这意味着整个 `rv64.bin` 文件的内容，从文件开头到所有加载段的末尾，都将被视为一个大的可加载块，并且它的加载起始地址就是你在 `SECTIONS` 中定义 `RAM` 的 `ORIGIN`。ELF 头和程序头表将位于文件的最前端。

-----

## **重要注意事项：关于链接脚本的调试**

在裸机开发中，链接脚本 (linker script) 是非常强大但也极其敏感的工具。一个微小的语法错误、对齐问题或概念上的误解都可能导致链接失败。在本项目调试 `link.ld` 时，我们遇到了以下常见的挑战：

1. **语法错误 (Syntax Error)**:

      * 链接器脚本有其独特的语法。像 C++ 风格的 `//` 注释（应使用 `/* ... */`）、不正确的关键字使用、或者缺少分号、大括号等都会导致 `syntax error`。
      * **排查技巧**: 仔细检查错误信息中指明的行号。如果确认语法无误，则可能是**隐藏字符**（例如复制粘贴时引入的非 ASCII 空格）。最可靠的方法是删除文件后**手动重新输入**相关部分，或者使用十六进制编辑器查看文件内容。

2. **`PHDR segment not covered by LOAD segment`**:

      * 这个错误意味着 ELF 文件中存在需要被加载的程序头段，但它没有被任何 `PT_LOAD` 类型的程序头所包含。对于简单的裸机程序，通常期望所有需要加载到内存的内容（包括 ELF 头和程序头本身）都由一个或少数几个 `PT_LOAD` 段来描述。
      * **排查技巧**: 确保你的 `PHDRS` 块中至少有一个 `PT_LOAD` 类型的程序头包含了 `FILEHDR` 和 `PHDRS` 关键字，并且这个 `PT_LOAD` 段的 `AT` 属性设置正确（通常是 `AT(0)`）。

3. **`Not enough room for program headers`**:

      * 这个错误表示链接器在生成 ELF 文件时，无法在预期的位置（通常是文件的起始部分）为 ELF 头和程序头表分配足够的空间。这通常发生在你的代码或数据段被指示从文件起始点太近的位置开始时。
      * **排查技巧**: 在 `SECTIONS` 块的第一个可加载段（例如 `.text_segment`）的开头，使用 `. = ALIGN(0x1000);` 或类似指令，显式地将该段的起始地址（以及文件偏移量）推后一个页面大小（4KB），为 ELF 头和 PHDRs 留出足够的空间。同时，确保 `PHDRS` 中的 `PT_LOAD` 段正确地使用了 `FILEHDR PHDRS AT(0)`。

4. **`Memory region not declared`**:

      * 当你尝试将一个段放置到 (`>`) 或关联到 (`:`) 一个 `MEMORY` 块中未定义的内存区域名称，或者将段错误地关联到 `PHDRS` 块中的程序头名称（当链接器期望内存区域名称时）时，会发生此错误。
      * **排查技巧**: 检查 `MEMORY` 块中的内存区域名称是否与 `SECTIONS` 块中使用的名称完全一致。同时，确认 `> MEMORY_REGION : PHDR_NAME` 这种组合语法的正确性，特别是当 `PHDR_NAME` 与 `MEMORY_REGION` 不符时。

**总结**: 理解 ELF 文件的基本结构以及链接器脚本的语法规则是解决这些问题的关键。
